// Generated by CoffeeScript 1.6.3
(function() {
  var SubTreeCollection,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  SubTreeCollection = (function() {
    function SubTreeCollection() {
      this.roots = [];
    }

    SubTreeCollection.prototype.add = function(node) {
      var i, newRoots, root, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      _ref = this.roots;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        root = _ref[_i];
        if (root.contains(node)) {
          return;
        }
      }
      newRoots = this.roots.slice();
      _ref1 = this.roots;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        root = _ref1[_j];
        if (node.contains(root)) {
          i = newRoots.indexOf(this);
          [].splice.apply(newRoots, [i, i - i + 1].concat(_ref2 = [])), _ref2;
        }
      }
      newRoots.push(node);
      return this.roots = newRoots;
    };

    return SubTreeCollection;

  })();

  window.DomTextMapper = (function(_super) {
    var SELECT_CHILDREN_INSTEAD, USE_EMPTY_TEXT_WORKAROUND, USE_TABLE_TEXT_WORKAROUND, WHITESPACE;

    __extends(DomTextMapper, _super);

    DomTextMapper.applicable = function() {
      return true;
    };

    USE_TABLE_TEXT_WORKAROUND = true;

    USE_EMPTY_TEXT_WORKAROUND = true;

    SELECT_CHILDREN_INSTEAD = ["table", "thead", "tbody", "tfoot", "ol", "a", "caption", "p", "span", "div", "h1", "h2", "h3", "h4", "h5", "h6", "ul", "li", "form"];

    DomTextMapper.instances = 0;

    function DomTextMapper(options) {
      var _ref;
      this.options = options != null ? options : {};
      this._onMutation = __bind(this._onMutation, this);
      this._onChange = __bind(this._onChange, this);
      this._getMappingsForCharRange = __bind(this._getMappingsForCharRange, this);
      this._getLengthForPath = __bind(this._getLengthForPath, this);
      this._getContentForPath = __bind(this._getContentForPath, this);
      this._getInfoForNode = __bind(this._getInfoForNode, this);
      this._getInfoForPath = __bind(this._getInfoForPath, this);
      DomTextMapper.__super__.constructor.call(this, (_ref = this.options.id) != null ? _ref : "d-t-m #" + DomTextMapper.instances);
      if (this.options.rootNode != null) {
        this.setRootNode(this.options.rootNode);
      } else {
        this.setRealRoot();
      }
      DomTextMapper.instances += 1;
      this._calculations = 0;
    }

    DomTextMapper.prototype._createSyncAPI = function() {
      DomTextMapper.__super__._createSyncAPI.apply(this, arguments);
      this._syncAPI.getInfoForPath = this._getInfoForPath;
      this._syncAPI.getContentForPath = this._getContentForPath;
      return this._syncAPI.getLengthForPath = this._getLengthForPath;
    };

    DomTextMapper.prototype.setRootNode = function(rootNode) {
      this.rootWin = window;
      return this.pathStartNode = this._changeRootNode(rootNode);
    };

    DomTextMapper.prototype.setRootId = function(rootId) {
      return this.setRootNode(document.getElementById(rootId));
    };

    DomTextMapper.prototype.setRootIframe = function(iframeId) {
      var iframe;
      iframe = window.document.getElementById(iframeId);
      if (iframe == null) {
        throw new Error("Can't find iframe with specified ID!");
      }
      this.rootWin = iframe.contentWindow;
      if (this.rootWin == null) {
        throw new Error("Can't access contents of the specified iframe!");
      }
      this._changeRootNode(this.rootWin.document);
      return this.pathStartNode = this.getBody();
    };

    DomTextMapper.prototype.getDefaultPath = function() {
      return this.getPathTo(this.pathStartNode);
    };

    DomTextMapper.prototype.setRealRoot = function() {
      this.rootWin = window;
      this._changeRootNode(document);
      return this.pathStartNode = this.getBody();
    };

    DomTextMapper.prototype.setExpectedContent = function(content) {
      return this.expectedContent = content;
    };

    DomTextMapper.prototype._startScan = function(reason) {
      var node, path, startTime, t1, t2;
      if (reason == null) {
        reason = "unknown reason";
      }
      if (this._pendingScan) {
        return;
      }
      this._pendingScan = true;
      if (this.path != null) {
        this._syncState(reason);
        this._scanFinished();
        return;
      }
      if (!this.pathStartNode.ownerDocument.body.contains(this.pathStartNode)) {
        throw new Error("This node is not attached to dom.");
      }
      this.log("Starting DOM scan, because", reason);
      this.observer.takeSummaries();
      startTime = this.timestamp();
      this.saveSelection();
      this.path = {};
      this.traverseSubTree(this.pathStartNode, this.getDefaultPath());
      t1 = this.timestamp();
      this.log("Phase I (Path traversal) took " + (t1 - startTime) + " ms.");
      path = this.getPathTo(this.pathStartNode);
      node = this.path[path].node;
      this.collectPositions(null, node, path, null, 0, 0);
      this._corpus = this.getNodeContent(this.path[path].node, false);
      this.restoreSelection();
      t2 = this.timestamp();
      this.log("Phase II (offset calculation) took " + (t2 - t1) + " ms.");
      this.log("Scan took", t2 - startTime, "ms.");
      return this._scanFinished();
    };

    DomTextMapper.prototype.selectPath = function(path, scroll) {
      var info, node;
      if (scroll == null) {
        scroll = false;
      }
      this.scan("selectPath('" + path + "')");
      info = this.path[path];
      if (info == null) {
        throw new Error("I have no info about a node at " + path);
      }
      node = info != null ? info.node : void 0;
      node || (node = this.lookUpNode(info.path));
      return this.selectNode(node, scroll);
    };

    DomTextMapper.prototype._performUpdateOnNode = function(node, reason) {
      var calculation, content, corpusChanged, data, lengthDelta, oldContent, oldEnd, oldIndex, oldStart, p, parentNode, parentPath, parentPathInfo, path, pathInfo, pathsToDrop, predecessorInfo, prefix, startTime, _i, _len;
      if (reason == null) {
        reason = "(no reason)";
      }
      if (!node) {
        throw new Error("Called performUpdate with a null node!");
      }
      if (!this.path) {
        return;
      }
      startTime = this.timestamp();
      path = this.getPathTo(node);
      pathInfo = this.path[path];
      while (!pathInfo) {
        node = node.parentNode;
        path = this.getPathTo(node);
        pathInfo = this.path[path];
      }
      if (node !== this.pathStartNode) {
        parentNode = node.parentNode;
        parentPath = this.getPathTo(parentNode);
        parentPathInfo = this.path[parentPath];
        while (parentPathInfo.irrelevant) {
          node = parentNode;
          path = parentPath;
          pathInfo = parentPathInfo;
          parentNode = node.parentNode;
          parentPath = this.getPathTo(parentNode);
          parentPathInfo = this.path[parentPath];
        }
      }
      this.saveSelection();
      oldContent = pathInfo.content;
      content = this.getNodeContent(node, false);
      corpusChanged = oldContent !== content;
      if (corpusChanged) {
        lengthDelta = content.length - oldContent.length;
      }
      prefix = path + "/";
      pathsToDrop = (function() {
        var _ref, _results;
        _ref = this.path;
        _results = [];
        for (p in _ref) {
          data = _ref[p];
          if (this.stringStartsWith(p, prefix)) {
            _results.push(p);
          }
        }
        return _results;
      }).call(this);
      if (corpusChanged) {
        pathsToDrop.push(path);
        if (!pathInfo.irrelevant) {
          oldStart = pathInfo.start;
          oldEnd = pathInfo.end;
        }
      }
      for (_i = 0, _len = pathsToDrop.length; _i < _len; _i++) {
        p = pathsToDrop[_i];
        delete this.path[p];
      }
      if (corpusChanged) {
        if (node !== this.pathStartNode) {
          this._alterAncestorsMappingData(node, pathInfo, oldStart, oldEnd, content);
          if (oldStart != null) {
            this._alterSiblingsMappingData(node, pathInfo, oldStart, oldEnd, content);
          }
        }
      }
      this.traverseSubTree(node, path);
      if (node === this.pathStartNode) {
        this.log("Ended up rescanning the whole doc.");
        this.collectPositions(null, node, path, null, 0, 0);
        this._updateCorpus(lengthDelta);
      } else {
        parentPath = this._parentPath(path);
        parentPathInfo = this.path[parentPath];
        predecessorInfo = this._findRelevantPredecessor(node, parentPath);
        oldIndex = predecessorInfo == null ? 0 : predecessorInfo.end - parentPathInfo.start;
        calculation = this._getNewCalculationId();
        this.collectPositions(calculation, node, path, parentPathInfo.content, parentPathInfo.start, oldIndex);
      }
      if (corpusChanged && (node !== this.pathStartNode) && (oldStart == null)) {
        pathInfo = this.path[path];
        oldStart = oldEnd = pathInfo.start;
        content = pathInfo.content;
        this._alterSiblingsMappingData(node, pathInfo, oldStart, oldEnd, content, calculation);
      }
      this.restoreSelection();
      return corpusChanged;
    };

    DomTextMapper.prototype._updateCorpus = function(lengthDelta) {
      var content;
      if (lengthDelta) {

      } else {
        lengthDelta = 0;
      }
      return this._corpus = (function() {
        if (this.expectedContent != null) {
          return this.expectedContent;
        } else {
          if (!this.path["."]) {
            this.log("We can't find info about root.");
            throw new Error("Internal error");
          }
          content = this.path["."].content;
          if (this._ignorePos != null) {
            this._ignorePos += lengthDelta;
            return content.slice(0, this._ignorePos);
          } else {
            return content;
          }
        }
      }).call(this);
    };

    DomTextMapper.prototype._alterAncestorsMappingData = function(node, nPathInfo, oldStart, oldEnd, newContent) {
      var lengthDelta, oldLength, oldPart, opEnd, opStart, pContent, pEnd, pStart, parentPath, parentPathInfo, prefix, suffix;
      oldLength = oldStart != null ? oldEnd - oldStart : 0;
      lengthDelta = newContent.length - oldLength;
      if (isNaN(lengthDelta)) {
        throw new Error("Internal error: got a NaN");
      }
      if (node === this.pathStartNode) {
        this._updateCorpus(lengthDelta);
        return;
      }
      parentPath = this._parentPath(nPathInfo.path);
      parentPathInfo = this.path[parentPath];
      if (parentPathInfo.irrelevant) {
        this.log("WARNING: irrelevant ancestors are not supposed to be present here.", "Expect trouble.");
      }
      if (parentPathInfo.irrelevant) {
        throw new Error("Internal error: we should never launch an update " + "from a child of an irrelevant node.");
      }
      if (oldStart != null) {
        if (oldEnd > parentPathInfo.end) {
          throw new Error("Internal error: child's alleged old end (" + oldEnd + ") is beyond the parent's end (" + parentPathInfo.end + ")!");
        }
        opStart = parentPathInfo.start;
        opEnd = parentPathInfo.end;
        pStart = oldStart - opStart;
        pEnd = oldEnd - opStart;
        if (pEnd > parentPathInfo.length) {
          throw new Error("Internal error: segment is supposed be at [" + pStart + "..." + pEnd + "], but parent's content is only " + parentPathInfo.length + " chars long!");
        }
        pContent = parentPathInfo.content;
        prefix = pContent.slice(0, pStart);
        oldPart = pContent.slice(pStart, pEnd);
        if (oldPart.length !== oldEnd - oldStart) {
          throw new Error("Internal error: oldPart's real length is " + oldPart.length + ", but oldEnd-oldStart is " + (oldEnd - oldStart));
        }
        suffix = pContent.slice(pEnd);
        parentPathInfo.content = pContent = prefix + newContent + suffix;
        parentPathInfo.length += lengthDelta;
        if (parentPathInfo.content.length !== parentPathInfo.length) {
          throw new Error("Length mismatch!");
        }
        if (parentPath === "." && parentPathInfo.length < 80) {
          throw new Error("Error: root length botched!");
        }
        if (parentPathInfo.length) {
          parentPathInfo.end += lengthDelta;
          if (isNaN(parentPathInfo.end)) {
            throw new Error("Internal error: got a NaN");
          }
        } else {
          if (!parentPathInfo.irrelevant) {
            this._markNodeAsIrrelevant(parentPathInfo.node, parentPath);
          }
          delete parentPathInfo.start;
          delete parentPathInfo.end;
        }
        return this._alterAncestorsMappingData(parentPathInfo.node, parentPathInfo, oldStart, oldEnd, newContent);
      } else {
        parentPathInfo.content = pContent = this.getNodeContent(parentPathInfo.node, false);
        parentPathInfo.length = pContent.length;
        if (parentPathInfo.length) {
          parentPathInfo.end = parentPathInfo.start + parentPathInfo.length;
          if (isNaN(parentPathInfo.end)) {
            throw new Error("Internal error: got a NaN");
          }
          return this._alterAncestorsMappingData(parentPathInfo.node, parentPathInfo, parentPathInfo.start, parentPathInfo.start, pContent);
        } else {
          opStart = parentPathInfo.start;
          opEnd = parentPathInfo.end;
          if (!parentPathInfo.irrelevant) {
            this._markNodeAsIrrelevant(parentPathInfo.node, parentPath);
          }
          delete parentPathInfo.start;
          delete parentPathInfo.end;
          return this._alterAncestorsMappingData(parentPathInfo.node, parentPathInfo, opStart, opEnd, "");
        }
      }
    };

    DomTextMapper.prototype._alterSiblingsMappingData = function(node, pathInfo, oldStart, oldEnd, newContent, calculationId) {
      var delta, info, p, _ref, _results;
      if (calculationId == null) {
        calculationId = NaN;
      }
      delta = newContent.length - (oldEnd - oldStart);
      if (!delta) {
        return;
      }
      _ref = this.path;
      _results = [];
      for (p in _ref) {
        info = _ref[p];
        if (!((!info.irrelevant) && info.calculatedAt !== calculationId && info.start >= oldEnd)) {
          continue;
        }
        info.start += delta;
        info.end += delta;
        if (isNaN(info.end)) {
          throw new Error("Internal error: got a NaN");
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    DomTextMapper.prototype._getInfoForPath = function(path) {
      var result;
      result = this.path[path];
      if (result == null) {
        throw new Error("Found no info for path '" + path + "'!");
      }
      return result;
    };

    DomTextMapper.prototype._getInfoForNode = function(node) {
      this._startScan("getInfoForNode()");
      if (node == null) {
        throw new Error("Called getInfoForNode(node) with null node!");
      }
      return this._getInfoForPath(this.getPathTo(node));
    };

    DomTextMapper.prototype._getContentForPath = function(path) {
      if (path == null) {
        path = null;
      }
      if (path == null) {
        path = this.getDefaultPath();
      }
      return this.path[path].content;
    };

    DomTextMapper.prototype._getLengthForPath = function(path) {
      if (path == null) {
        path = null;
      }
      if (path == null) {
        path = this.getDefaultPath();
      }
      return this.path[path].length;
    };

    DomTextMapper.prototype._getMappingsForCharRange = function(start, end) {
      var endInfo, endMapping, endNode, endOffset, endPath, info, mappings, p, r, result, startInfo, startMapping, startNode, startOffset, startPath, _ref,
        _this = this;
      this._startScan("getMappingsForCharRange()");
      if (!((start != null) && (end != null))) {
        throw new Error("start and end is required!");
      }
      mappings = [];
      _ref = this.path;
      for (p in _ref) {
        info = _ref[p];
        if (info.atomic && this._regions_overlap(info.start, info.end, start, end)) {
          (function(info) {
            var full, mapping;
            mapping = {
              element: info
            };
            full = start <= info.start && info.end <= end;
            if (full) {
              mapping.full = true;
              mapping.wanted = info.content;
              mapping.yields = info.content;
              mapping.startCorrected = 0;
              mapping.endCorrected = 0;
            } else {
              if (info.node.nodeType === Node.TEXT_NODE) {
                if (start <= info.start) {
                  mapping.end = end - info.start;
                  mapping.wanted = info.content.substr(0, mapping.end);
                } else if (info.end <= end) {
                  mapping.start = start - info.start;
                  mapping.wanted = info.content.substr(mapping.start);
                } else {
                  mapping.start = start - info.start;
                  mapping.end = end - info.start;
                  mapping.wanted = info.content.substr(mapping.start, mapping.end - mapping.start);
                }
                _this.computeSourcePositions(mapping);
                mapping.yields = info.node.data.substr(mapping.startCorrected, mapping.endCorrected - mapping.startCorrected);
              } else if ((info.node.nodeType === Node.ELEMENT_NODE) && (info.node.tagName.toLowerCase() === "img")) {
                _this.log("Can not select a sub-string from the title of an image. Selecting all.");
                mapping.full = true;
                mapping.wanted = info.content;
              } else {
                _this.log("Warning: no idea how to handle partial mappings for node type " + info.node.nodeType);
                if (info.node.tagName != null) {
                  _this.log("Tag: " + info.node.tagName);
                }
                _this.log("Selecting all.");
                mapping.full = true;
                mapping.wanted = info.content;
              }
            }
            return mappings.push(mapping);
          })(info);
        }
      }
      if (mappings.length === 0) {
        this.log("Collecting nodes for [" + start + ":" + end + "]");
        this.log("Should be: '" + this._corpus.slice(start, end) + "'.");
        throw new Error("No mappings found for [" + start + ":" + end + "]!");
      }
      mappings = mappings.sort(function(a, b) {
        return a.element.start - b.element.start;
      });
      r = this.rootWin.document.createRange();
      startMapping = mappings[0];
      startNode = startMapping.element.node;
      startPath = startMapping.element.path;
      startOffset = startMapping.startCorrected;
      if (startMapping.full) {
        r.setStartBefore(startNode);
        startInfo = startPath;
      } else {
        r.setStart(startNode, startOffset);
        startInfo = startPath + ":" + startOffset;
      }
      endMapping = mappings[mappings.length - 1];
      endNode = endMapping.element.node;
      endPath = endMapping.element.path;
      endOffset = endMapping.endCorrected;
      if (endMapping.full) {
        r.setEndAfter(endNode);
        endInfo = endPath;
      } else {
        r.setEnd(endNode, endOffset);
        endInfo = endPath + ":" + endOffset;
      }
      result = {
        mappings: mappings,
        realRange: r,
        rangeInfo: {
          startPath: startPath,
          startOffset: startOffset,
          startInfo: startInfo,
          endPath: endPath,
          endOffset: endOffset,
          endInfo: endInfo
        },
        safeParent: r.commonAncestorContainer
      };
      return {
        sections: [result]
      };
    };

    DomTextMapper.prototype.ready = function(reason, callback) {
      if (callback == null) {
        throw new Error("missing callback!");
      }
      if (this._pendingCallbacks == null) {
        this._pendingCallbacks = [];
      }
      this._pendingCallbacks.push(callback);
      this._startScan(reason);
      return null;
    };

    DomTextMapper.prototype.stringStartsWith = function(string, prefix) {
      if (!prefix) {
        throw Error("Requires a non-empty prefix!");
      }
      return string.slice(0, prefix.length) === prefix;
    };

    DomTextMapper.prototype.stringEndsWith = function(string, suffix) {
      if (!suffix) {
        throw Error("Requires a non-empty suffix!");
      }
      return string.slice(string.length - suffix.length, string.length) === suffix;
    };

    DomTextMapper.prototype._parentPath = function(path) {
      return path.substr(0, path.lastIndexOf("/"));
    };

    DomTextMapper.prototype.getProperNodeName = function(node) {
      var nodeName;
      nodeName = node.nodeName;
      switch (nodeName) {
        case "#text":
          return "text()";
        case "#comment":
          return "comment()";
        case "#cdata-section":
          return "cdata-section()";
        default:
          return nodeName;
      }
    };

    DomTextMapper.prototype._enumerateChildren = function(node, path) {
      var child, childPath, children, i, newCount, nodeName, oldCount, results, typeCount;
      if (!node.hasChildNodes()) {
        return [];
      }
      results = [];
      children = node.childNodes;
      i = 0;
      typeCount = Object();
      while (i < children.length) {
        child = children[i];
        nodeName = this.getProperNodeName(child);
        oldCount = typeCount[nodeName];
        newCount = oldCount != null ? oldCount + 1 : 1;
        typeCount[nodeName] = newCount;
        childPath = path + "/" + nodeName + (newCount > 1 ? "[" + newCount + "]" : "");
        results.push({
          node: child,
          path: childPath
        });
        i++;
      }
      return results;
    };

    DomTextMapper.prototype._findRelevantPredecessor = function(successor, parentPath) {
      var info, node, path;
      node = successor.previousSibling;
      while (node) {
        path = parentPath + "/" + this.getPathSegment(node);
        info = this.path[path];
        if (info == null) {
          throw new Error("Internal error: found no data for path " + path + ". (Wondered into ignored area?");
        }
        if (info.irrelevant) {
          node = node.previousSibling;
        } else {
          return info;
        }
      }
      return null;
    };

    DomTextMapper.prototype.getNodePosition = function(node) {
      var pos, tmp;
      pos = 0;
      tmp = node;
      while (tmp) {
        if (tmp.nodeName === node.nodeName) {
          pos++;
        }
        tmp = tmp.previousSibling;
      }
      return pos;
    };

    DomTextMapper.prototype.getPathSegment = function(node) {
      var name, pos;
      name = this.getProperNodeName(node);
      pos = this.getNodePosition(node);
      return name + (pos > 1 ? "[" + pos + "]" : "");
    };

    DomTextMapper.prototype.getPathTo = function(node) {
      var origNode, xpath;
      if (!(origNode = node)) {
        throw new Error("Called getPathTo with null node!");
      }
      xpath = '';
      while (node !== this.rootNode) {
        if (node == null) {
          this.log("Root node:", this.rootNode);
          this.log("Wanted node:", origNode);
          this.log("Is this even a child?", this.rootNode.contains(origNode));
          throw new Error("Called getPathTo on a node which was not a descendant of the configured root node.");
        }
        xpath = (this.getPathSegment(node)) + '/' + xpath;
        node = node.parentNode;
      }
      xpath = (this.rootNode.ownerDocument != null ? './' : '/') + xpath;
      xpath = xpath.replace(/\/$/, '');
      return xpath;
    };

    DomTextMapper.prototype.traverseSubTree = function(node, path, invisible, verbose) {
      var cont, debug, item, _i, _len, _ref;
      if (invisible == null) {
        invisible = false;
      }
      if (verbose == null) {
        verbose = false;
      }
      debug = false;
      if (debug) {
        this.log("Traversing path", path);
      }
      if (this._isIgnored(node)) {
        return;
      }
      this.underTraverse = path;
      cont = this.getNodeContent(node, false);
      this.path[path] = {
        path: path,
        content: cont,
        length: cont.length,
        node: node
      };
      if (cont.length) {
        if (verbose) {
          this.log("Collected info @", path);
        }
        if (invisible) {
          this.log("Something seems to be wrong. I see visible content @ " + path + ", while some of the ancestor nodes reported empty contents. Probably a new selection API bug....");
          this.log("Anyway, text is '" + cont + "'.");
        }
      } else {
        if (verbose) {
          this.log("Found no content @" + path);
        }
        invisible = true;
      }
      _ref = this._enumerateChildren(node, path);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        this.traverseSubTree(item.node, item.path, invisible, verbose);
      }
      return null;
    };

    DomTextMapper.prototype.getBody = function() {
      return (this.rootWin.document.getElementsByTagName("body"))[0];
    };

    DomTextMapper.prototype._regions_overlap = function(start1, end1, start2, end2) {
      return start1 < end2 && start2 < end1;
    };

    DomTextMapper.prototype.lookUpNode = function(path) {
      var doc, node, results, _ref;
      doc = (_ref = this.rootNode.ownerDocument) != null ? _ref : this.rootNode;
      results = doc.evaluate(path, this.rootNode, null, 0, null);
      return node = results.iterateNext();
    };

    DomTextMapper.prototype.saveSelection = function() {
      var i, sel;
      if (this.savedSelection != null) {
        this.log("Selection saved at:");
        this.log(this.selectionSaved);
        throw new Error("Selection already saved!");
      }
      sel = this.rootWin.getSelection();
      this.savedSelection = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = sel.rangeCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(sel.getRangeAt(i));
        }
        return _results;
      })();
      return this.selectionSaved = (new Error("selection was saved here")).stack;
    };

    DomTextMapper.prototype.restoreSelection = function() {
      var range, sel, _i, _len, _ref;
      if (this.savedSelection == null) {
        throw new Error("No selection to restore.");
      }
      sel = this.rootWin.getSelection();
      sel.removeAllRanges();
      _ref = this.savedSelection;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        range = _ref[_i];
        sel.addRange(range);
      }
      return delete this.savedSelection;
    };

    DomTextMapper.prototype.selectNode = function(node, scroll) {
      var children, exception, realRange, sel, sn, _ref;
      if (scroll == null) {
        scroll = false;
      }
      if (node == null) {
        throw new Error("Called selectNode with null node!");
      }
      sel = this.rootWin.getSelection();
      sel.removeAllRanges();
      realRange = this.rootWin.document.createRange();
      if (node.nodeType === Node.ELEMENT_NODE && node.hasChildNodes() && (_ref = node.tagName.toLowerCase(), __indexOf.call(SELECT_CHILDREN_INSTEAD, _ref) >= 0)) {
        children = node.childNodes;
        realRange.setStartBefore(children[0]);
        realRange.setEndAfter(children[children.length - 1]);
        sel.addRange(realRange);
      } else {
        if (USE_TABLE_TEXT_WORKAROUND && node.nodeType === Node.TEXT_NODE && this.isWhitespace(node)) {

        } else {
          try {
            realRange.setStartBefore(node);
            realRange.setEndAfter(node);
            sel.addRange(realRange);
          } catch (_error) {
            exception = _error;
            if (!(USE_EMPTY_TEXT_WORKAROUND && this.isWhitespace(node))) {
              this.log("Warning: failed to scan element @ " + this.underTraverse);
              this.log("Content is: " + node.innerHTML);
              this.log("We won't be able to properly anchor to any text inside this element.");
            }
          }
        }
      }
      if (scroll) {
        sn = node;
        while ((sn != null) && (sn.scrollIntoViewIfNeeded == null)) {
          sn = sn.parentNode;
        }
        if (sn != null) {
          sn.scrollIntoViewIfNeeded();
        } else {
          this.log("Failed to scroll to element. (Browser does not support scrollIntoViewIfNeeded?)");
        }
      }
      return sel;
    };

    DomTextMapper.prototype.readSelectionText = function(sel) {
      sel || (sel = this.rootWin.getSelection());
      return sel.toString().trim().replace(/\n/g, " ").replace(/\s{2,}/g, " ");
    };

    DomTextMapper.prototype.getNodeSelectionText = function(node, shouldRestoreSelection) {
      var sel, text;
      if (shouldRestoreSelection == null) {
        shouldRestoreSelection = true;
      }
      if (shouldRestoreSelection) {
        this.saveSelection();
      }
      sel = this.selectNode(node);
      text = this.readSelectionText(sel);
      if (shouldRestoreSelection) {
        this.restoreSelection();
      }
      return text;
    };

    DomTextMapper.prototype.computeSourcePositions = function(match) {
      var dc, displayEnd, displayIndex, displayStart, displayText, sc, sourceEnd, sourceIndex, sourceStart, sourceText;
      this.log("In computeSourcePosition", match.element.path, match.element.node.data);
      sourceText = match.element.node.data.replace(/\n/g, " ");
      displayText = match.element.content;
      if (displayText.length > sourceText.length) {
        throw new Error("Invalid match at" + match.element.path + ": sourceText is '" + sourceText + "'," + " displayText is '" + displayText + "'.");
      }
      displayStart = match.start != null ? match.start : 0;
      displayEnd = match.end != null ? match.end : displayText.length;
      if (displayEnd === 0) {
        match.startCorrected = 0;
        match.endCorrected = 0;
        return;
      }
      sourceIndex = 0;
      displayIndex = 0;
      while (!((sourceStart != null) && (sourceEnd != null))) {
        sc = sourceText[sourceIndex];
        dc = displayText[displayIndex];
        if (sc === dc) {
          if (displayIndex === displayStart) {
            sourceStart = sourceIndex;
          }
          displayIndex++;
          if (displayIndex === displayEnd) {
            sourceEnd = sourceIndex + 1;
          }
        }
        sourceIndex++;
      }
      match.startCorrected = sourceStart;
      match.endCorrected = sourceEnd;
      return null;
    };

    DomTextMapper.prototype.getNodeContent = function(node, shouldRestoreSelection) {
      var content;
      if (shouldRestoreSelection == null) {
        shouldRestoreSelection = true;
      }
      if ((node === this.pathStartNode) && (this.expectedContent != null)) {
        return this.expectedContent;
      }
      content = this.getNodeSelectionText(node, shouldRestoreSelection);
      if ((node === this.pathStartNode) && (this._ignorePos != null)) {
        return content.slice(0, this._ignorePos);
      }
      return content;
    };

    DomTextMapper.prototype._markNodeAsIrrelevant = function(node, path, verbose) {
      var info, item, _i, _len, _ref, _results;
      if (verbose) {
        this.log("Marking node @", path, "as irrelevant.");
      }
      info = this.path[path];
      if (info) {
        info.irrelevant = true;
        _ref = this._enumerateChildren(node, path, verbose);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          _results.push(this._markNodeAsIrrelevant(item.node, item.path, verbose));
        }
        return _results;
      }
    };

    DomTextMapper.prototype._getNewCalculationId = function() {
      return this._calculations++;
    };

    DomTextMapper.prototype.collectPositions = function(calculationId, node, path, parentContent, parentIndex, index) {
      var atomic, content, debug, endIndex, item, pathInfo, pos, startIndex, _i, _len, _ref;
      if (parentContent == null) {
        parentContent = null;
      }
      if (parentIndex == null) {
        parentIndex = 0;
      }
      if (index == null) {
        index = 0;
      }
      if (calculationId == null) {
        calculationId = this._getNewCalculationId();
      }
      if (isNaN(parentIndex)) {
        throw new Error("Internal error: got a NaN");
      }
      debug = false;
      if (debug) {
        this.log("Post-processing path ", path);
      }
      if (this._isIgnored(node, false, debug)) {
        if (debug) {
          this.log("This is ignored!");
        }
        pos = parentIndex + index;
        if (!((this._ignorePos != null) && this._ignorePos < pos)) {
          this._ignorePos = pos;
        }
        return index;
      }
      pathInfo = this.path[path];
      pathInfo.calculatedAt = calculationId;
      content = pathInfo != null ? pathInfo.content : void 0;
      if (!content) {
        pathInfo.start = parentIndex + index;
        pathInfo.end = parentIndex + index;
        if (isNaN(pathInfo.end)) {
          throw new Error("Internal error: got a NaN");
        }
        pathInfo.atomic = false;
        if (debug) {
          this.log("Path", path, "is empty; setting it to atomic.");
        }
        this._markNodeAsIrrelevant(node, path, debug);
        return index;
      }
      startIndex = parentContent != null ? parentContent.indexOf(content, index) : index;
      if (startIndex === -1) {
        throw new Error("The content @ '" + path + "' is not present in the content of it's parent. " + "(Content: '" + content + "'.)");
      }
      endIndex = startIndex + content.length;
      atomic = !node.hasChildNodes();
      pathInfo.start = parentIndex + startIndex;
      pathInfo.end = parentIndex + endIndex;
      if (isNaN(pathInfo.end)) {
        throw new Error("Internal error: got a NaN");
      }
      pathInfo.atomic = atomic;
      if (debug) {
        this.log("Is", path, "atomic?", atomic);
      }
      if (!atomic) {
        _ref = this._enumerateChildren(node, path);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          pos = this.collectPositions(calculationId, item.node, item.path, content, parentIndex + startIndex, pos);
        }
      }
      return endIndex;
    };

    WHITESPACE = /^\s*$/;

    DomTextMapper.prototype.isWhitespace = function(node) {
      var child, mightBeEmpty, result;
      result = (function() {
        var _i, _len, _ref;
        switch (node.nodeType) {
          case Node.TEXT_NODE:
            return WHITESPACE.test(node.data);
          case Node.ELEMENT_NODE:
            mightBeEmpty = true;
            _ref = node.childNodes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              mightBeEmpty = mightBeEmpty && this.isWhitespace(child);
            }
            return mightBeEmpty;
          default:
            return false;
        }
      }).call(this);
      return result;
    };

    DomTextMapper.prototype._testNodeMapping = function(path, info, verbose) {
      var diff, inCorpus, ok1, ok2, ok3, realContent;
      if (verbose == null) {
        verbose = false;
      }
      if (info == null) {
        info = this.path[path];
      }
      if (!info) {
        console.trace();
        throw new Error("Could not look up node @ '" + path + "'!");
      }
      inCorpus = (info.start != null) && (info.end != null) ? this._corpus.slice(info.start, info.end) : "";
      realContent = this.getNodeContent(info.node);
      ok1 = info.content === inCorpus;
      ok2 = info.content === realContent;
      if (verbose && !(ok1 && ok2)) {
        if (this.dmp == null) {
          this.dmp = new DTM_DMPMatcher();
        }
        ok3 = inCorpus === realContent;
        if (ok1) {
          this.log("X=*=*=X Stored and corpus content matches at", path);
        } else {
          diff = this.dmp.compare(info.content, inCorpus);
          this.log("X=*=*=X Mismatch between stored content and corpus[", info.start, "...", info.end, "] at", path, diff.diff);
        }
        if (ok2) {
          this.log("X=*=*=X Stored and actual content matches at", path);
        } else {
          diff = this.dmp.compare(info.content, realContent);
          this.log("X=*=*=X Mismatch between stored and actual content at", path, diff.diff);
        }
        if (ok3) {
          this.log("X=*=*=X Corpus and actual content matches at", path);
        } else {
          diff = this.dmp.compare(inCorpus, realContent);
          this.log("X=*=*=X Mismatch between corpus[", info.start, "...", info.end, "] and actual content at", path, diff.diff);
        }
      }
      return ok1 && ok2;
    };

    DomTextMapper.prototype._testAllMappings = function(verbose) {
      var correct, i, info, p, path, _ref, _ref1;
      if (verbose == null) {
        verbose = false;
      }
      this.log("Verifying map info: was it all properly traversed & post-processed?");
      correct = true;
      _ref = this.path;
      for (i in _ref) {
        p = _ref[i];
        if (!(p.irrelevant || (p.atomic != null))) {
          if (verbose || correct) {
            this.log(i, "is missing data.");
          }
          correct = false;
        }
      }
      if (!correct) {
        return false;
      }
      this.log("Verifying map info: do nodes match?");
      _ref1 = this.path;
      for (path in _ref1) {
        info = _ref1[path];
        if (!this._testNodeMapping(path, info, verbose)) {
          if (correct && !verbose) {
            this._testNodeMapping(path, info, true);
          }
          correct = false;
        }
      }
      return correct;
    };

    DomTextMapper.prototype.getPageIndex = function() {
      return 0;
    };

    DomTextMapper.prototype.getPageCount = function() {
      return 1;
    };

    DomTextMapper.prototype.getPageRoot = function() {
      return this.rootNode;
    };

    DomTextMapper.prototype._getPageIndexForPos = function() {
      return 0;
    };

    DomTextMapper.prototype.isPageMapped = function() {
      return true;
    };

    DomTextMapper.prototype._getIgnoredParts = function() {
      if (this.options.getIgnoredParts) {
        if (this._ignoredParts && this.options.cacheIgnoredParts) {
          return this._ignoredParts;
        } else {
          return this._ignoredParts = this.options.getIgnoredParts();
        }
      } else {
        return [];
      }
    };

    DomTextMapper.prototype._isIrrelevant = function(node) {
      var _ref;
      return node.nodeType === Node.ELEMENT_NODE && ((_ref = node.tagName.toLowerCase()) === "canvas" || _ref === "script");
    };

    DomTextMapper.prototype._isIgnored = function(node, ignoreIrrelevant, debug) {
      var container, _i, _len, _ref;
      if (ignoreIrrelevant == null) {
        ignoreIrrelevant = false;
      }
      if (debug == null) {
        debug = false;
      }
      if (!this.pathStartNode.contains(node)) {
        if (debug) {
          this.log("Node", node, "is ignored, because it's not a descendant of", this.pathStartNode, ".");
        }
        return true;
      }
      _ref = this._getIgnoredParts();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        container = _ref[_i];
        if (container.contains(node)) {
          if (debug) {
            this.log("Node", node, "is ignore, because it's a descendant of", containter);
          }
          return true;
        }
      }
      if (ignoreIrrelevant) {
        if (this._isIrrelevant(node)) {
          if (debug) {
            this.log("Node", node, "is ignored, because it's irrelevant.");
          }
          return true;
        }
      }
      if (debug) {
        this.log("Node", node, "is NOT ignored.");
      }
      return false;
    };

    DomTextMapper.prototype._isAttributeChangeImportant = function(node, attributeName, oldValue, newValue) {
      if (this.options.filterAttributeChanges) {
        return this.options.filterAttributeChanges(node, attributeName, oldValue, newValue);
      } else {
        return true;
      }
    };

    DomTextMapper.prototype._filterChanges = function(changes) {
      var attrName, attributeChanged, attributeChangedCount, elementList, k, list, removed, v, _ref, _ref1, _ref2,
        _this = this;
      if (this._getIgnoredParts().length === 0) {
        return changes;
      }
      changes.added = changes.added.filter(function(element) {
        return !_this._isIgnored(element, true);
      });
      removed = changes.removed;
      changes.removed = removed.filter(function(element) {
        var parent;
        parent = element;
        while (__indexOf.call(removed, parent) >= 0) {
          parent = changes.getOldParentNode(parent);
        }
        return !_this._isIgnored(element, true);
      });
      attributeChanged = {};
      _ref1 = (_ref = changes.attributeChanged) != null ? _ref : {};
      for (attrName in _ref1) {
        elementList = _ref1[attrName];
        list = elementList.filter(function(element) {
          return !_this._isIgnored(element, true);
        });
        list = list.filter(function(element) {
          return _this._isAttributeChangeImportant(element, attrName, changes.getOldAttribute(element, attrName), element.getAttribute(attrName));
        });
        if (list.length) {
          attributeChanged[attrName] = list;
        }
      }
      changes.attributeChanged = attributeChanged;
      changes.characterDataChanged = changes.characterDataChanged.filter(function(element) {
        return !_this._isIgnored(element, true);
      });
      changes.reordered = changes.reordered.filter(function(element) {
        var parent;
        parent = element.parentNode;
        return !_this._isIgnored(parent, true);
      });
      attributeChangedCount = 0;
      _ref2 = changes.attributeChanged;
      for (k in _ref2) {
        v = _ref2[k];
        attributeChangedCount++;
      }
      if (changes.added.length || changes.characterDataChanged.length || changes.removed.length || changes.reordered.length || changes.reparented.length || attributeChangedCount) {
        return changes;
      } else {
        return null;
      }
      return changes;
    };

    DomTextMapper.prototype._addToTrees = function() {
      var data, node, reason, trees;
      trees = arguments[0], node = arguments[1], reason = arguments[2], data = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
      if (!this.pathStartNode.contains(node)) {
        return null;
      }
      trees.add(node);
      if (node === this.pathStartNode) {
        return this.log.apply(this, ["Added change on root node, because", reason].concat(__slice.call(data)));
      }
    };

    DomTextMapper.prototype._getInvolvedNodes = function(changes) {
      var k, list, n, parent, trees, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      trees = new SubTreeCollection();
      _ref = changes.added;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        this._addToTrees(trees, n.parentNode, "a child was added", n);
      }
      _ref1 = changes.attributeChanged;
      for (k in _ref1) {
        list = _ref1[k];
        for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
          n = list[_j];
          this._addToTrees(trees, n, "attribute changed", k, n.getAttribute(k));
        }
      }
      _ref2 = changes.characterDataChanged;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        n = _ref2[_k];
        this._addToTrees(trees, n, "data content changed");
      }
      _ref3 = changes.removed;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        n = _ref3[_l];
        parent = n;
        while ((__indexOf.call(changes.removed, parent) >= 0) || (__indexOf.call(changes.reparented, parent) >= 0)) {
          parent = changes.getOldParentNode(parent);
        }
        this._addToTrees(trees, n, "a child was removed");
      }
      _ref4 = changes.reordered;
      for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
        n = _ref4[_m];
        this._addToTrees(trees, n.parentNode, "children were reordered");
      }
      _ref5 = changes.reparented;
      for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
        n = _ref5[_n];
        this._addToTrees(trees, n.parentNode, "reparented node landed here");
        parent = n;
        while ((__indexOf.call(changes.removed, parent) >= 0) || (__indexOf.call(changes.reparented, parent) >= 0)) {
          parent = changes.getOldParentNode(parent);
        }
        this._addToTrees(trees, parent, "child was reparented from here");
      }
      return trees.roots;
    };

    DomTextMapper.prototype._reactToChanges = function(reason, changes, data) {
      var changedNodes, corpusChanged, node, _i, _len,
        _this = this;
      if (changes) {
        changes = this._filterChanges(changes);
      }
      if (!changes) {
        return;
      }
      changedNodes = this._getInvolvedNodes(changes);
      corpusChanged = false;
      for (_i = 0, _len = changedNodes.length; _i < _len; _i++) {
        node = changedNodes[_i];
        if (this._performUpdateOnNode(node, reason, false, data)) {
          corpusChanged = true;
        }
      }
      if (corpusChanged) {
        return setTimeout(function() {
          var event;
          event = document.createEvent("UIEvents");
          event.initUIEvent("corpusChange", true, false, window, 0);
          return _this.rootNode.dispatchEvent(event);
        });
      }
    };

    DomTextMapper.prototype._syncState = function(reason, data) {
      var summaries;
      if (reason == null) {
        reason = "i am in the mood";
      }
      summaries = this.observer.takeSummaries();
      return this._reactToChanges("SyncState for " + reason, summaries != null ? summaries[0] : void 0, data);
    };

    DomTextMapper.prototype._onChange = function(event) {
      return this._syncState("change event '" + event.reason + "'", event.data);
    };

    DomTextMapper.prototype._onMutation = function(summaries) {
      return this._reactToChanges("Observer called", summaries[0]);
    };

    DomTextMapper.prototype._changeRootNode = function(node) {
      var _ref;
      if ((_ref = this.observer) != null) {
        _ref.disconnect();
      }
      this.rootNode = node;
      this.observer = new MutationSummary({
        callback: this._onMutation,
        rootNode: node,
        queries: [
          {
            all: true
          }
        ]
      });
      return node;
    };

    return DomTextMapper;

  })(TextMapperCore);

}).call(this);

/*
//@ sourceMappingURL=dom_text_mapper.map
*/
