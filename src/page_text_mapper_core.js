// Generated by CoffeeScript 1.6.3
(function() {
  var _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.PageTextMapperCore = (function(_super) {
    __extends(PageTextMapperCore, _super);

    function PageTextMapperCore() {
      this._getMappingsForCharRange = __bind(this._getMappingsForCharRange, this);
      this._getEndInfoForNode = __bind(this._getEndInfoForNode, this);
      this._getStartInfoForNode = __bind(this._getStartInfoForNode, this);
      this._onPageRendered = __bind(this._onPageRendered, this);
      this._getPageIndexForPos = __bind(this._getPageIndexForPos, this);
      _ref = PageTextMapperCore.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    PageTextMapperCore.prototype._getPageIndexForPos = function(pos) {
      var info, _i, _len, _ref1;
      _ref1 = this._pageInfo;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        info = _ref1[_i];
        if ((info.start <= pos && pos < info.end)) {
          return info.index;
          this._log("Not on page " + info.index);
        }
      }
      return -1;
    };

    PageTextMapperCore.prototype._onPageRendered = function(index) {
      var _this = this;
      if (!this._isPageRendered(index)) {
        setTimeout((function() {
          return _this._onPageRendered(index);
        }), 1000);
        return;
      }
      return this._mapPage(this._pageInfo[index], "page has been rendered");
    };

    PageTextMapperCore.prototype.isPageMapped = function(index) {
      var _ref1;
      return ((_ref1 = this._pageInfo[index]) != null ? _ref1.domMapper : void 0) != null;
    };

    PageTextMapperCore.prototype._mapPage = function(info, reason) {
      var _this = this;
      info.node = this.getPageRoot(info.index);
      info.domMapper = new DomTextMapper({
        id: "d-t-m for page #" + info.index,
        rootNode: info.node
      });
      if (this._requiresSmartStringPadding) {
        info.domMapper.setExpectedContent(info.content);
      }
      return info.domMapper.ready(reason, function(s) {
        var renderedContent;
        renderedContent = s.getCorpus();
        if (renderedContent !== info.content) {
          _this._log("Oops. Mismatch between rendered and extracted text, while mapping page #" + info.index + "!");
          console.trace();
          _this._log("Rendered: " + renderedContent);
          _this._log("Extracted: " + info.content);
        }
        info.node.addEventListener("corpusChange", function() {
          _this._log("Ooops. Corpus has changed on one of the pages!");
          return _this._log("TODO: We should do something about this, to update the global corpus!");
        });
        return setTimeout(function() {
          var event;
          event = document.createEvent("UIEvents");
          event.initUIEvent("docPageMapped", false, false, window, 0);
          event.pageIndex = info.index;
          return window.dispatchEvent(event);
        });
      });
    };

    PageTextMapperCore.prototype._readyAllPages = function(reason, callback) {
      var cycleOver, endTriggered, pagesToGo,
        _this = this;
      pagesToGo = 0;
      cycleOver = false;
      endTriggered = false;
      this._pageInfo.forEach(function(info, i) {
        if (_this._isPageRendered(i)) {
          pagesToGo++;
          return info.domMapper.ready(reason, function() {
            pagesToGo--;
            if (pagesToGo === 0 && cycleOver && !endTriggered) {
              endTriggered = true;
              return callback("Done");
            }
          });
        }
      });
      cycleOver = true;
      if (!endTriggered) {
        endTriggered = true;
        return callback("Done");
      }
    };

    PageTextMapperCore.prototype._unmapPage = function(info) {
      var event;
      delete info.domMapper;
      event = document.createEvent("UIEvents");
      event.initUIEvent("docPageUnmapped", false, false, window, 0);
      event.pageIndex = info.index;
      return window.dispatchEvent(event);
    };

    PageTextMapperCore.prototype._onScroll = function() {
      var event;
      event = document.createEvent("UIEvents");
      event.initUIEvent("docPageScrolling", false, false, window, 0);
      return window.dispatchEvent(event);
    };

    PageTextMapperCore.prototype._getStartInfoForNode = function(node) {
      var info, k, nodeData, pageData, v;
      pageData = this._getPageForNode(node);
      nodeData = pageData.domMapper._getStartInfoForNode(node);
      if (!nodeData) {
        return null;
      }
      info = {};
      for (k in nodeData) {
        v = nodeData[k];
        info[k] = v;
      }
      info.start += pageData.start;
      info.pageIndex = pageData.index;
      return info;
    };

    PageTextMapperCore.prototype._getEndInfoForNode = function(node) {
      var info, k, nodeData, pageData, v;
      pageData = this._getPageForNode(node);
      nodeData = pageData.domMapper._getEndInfoForNode(node);
      if (!nodeData) {
        return null;
      }
      info = {};
      for (k in nodeData) {
        v = nodeData[k];
        info[k] = v;
      }
      info.end += pageData.start;
      info.pageIndex = pageData.index;
      return info;
    };

    PageTextMapperCore.prototype._getMappingsForCharRange = function(start, end, pages) {
      var endIndex, getSection, index, sections, startIndex, _i, _j, _len, _ref1, _results,
        _this = this;
      startIndex = this._getPageIndexForPos(start);
      endIndex = this._getPageIndexForPos(end);
      getSection = function(index) {
        var info, mappings, realEnd, realStart;
        info = _this._pageInfo[index];
        realStart = (Math.max(info.start, start)) - info.start;
        realEnd = (Math.min(info.end, end)) - info.start;
        mappings = info.domMapper._getMappingsForCharRange(realStart, realEnd);
        return mappings.sections[0];
      };
      sections = {};
      _ref1 = pages != null ? pages : (function() {
        _results = [];
        for (var _j = startIndex; startIndex <= endIndex ? _j <= endIndex : _j >= endIndex; startIndex <= endIndex ? _j++ : _j--){ _results.push(_j); }
        return _results;
      }).apply(this);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        index = _ref1[_i];
        sections[index] = getSection(index);
      }
      return {
        sections: sections
      };
    };

    PageTextMapperCore.prototype._onHavePageContents = function() {
      var info, pos,
        _this = this;
      this._corpus = ((function() {
        var _i, _len, _ref1, _results;
        _ref1 = this._pageInfo;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          info = _ref1[_i];
          _results.push(info.content);
        }
        return _results;
      }).call(this)).join(" ");
      pos = 0;
      return this._pageInfo.forEach(function(info, i) {
        info.index = i;
        info.len = info.content.length;
        info.start = pos;
        return info.end = (pos += info.len + 1);
      });
    };

    PageTextMapperCore.prototype._onAfterTextExtraction = function() {
      var _this = this;
      return this._pageInfo.forEach(function(info, i) {
        if (_this._isPageRendered(i)) {
          return _this._mapPage(info, "text extraction finished");
        }
      });
    };

    PageTextMapperCore.prototype._testAllMappings = function() {
      var _this = this;
      return this._pageInfo.forEach(function(info, i) {
        var _ref1;
        return (_ref1 = info.domMapper) != null ? typeof _ref1._testAllMappings === "function" ? _ref1._testAllMappings() : void 0 : void 0;
      });
    };

    return PageTextMapperCore;

  })(TextMapperCore);

}).call(this);

/*
//@ sourceMappingURL=page_text_mapper_core.map
*/
